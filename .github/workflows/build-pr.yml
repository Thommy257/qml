name: Build Website
on:
  pull_request:
  push:
    branches:
      - master
      - dev

env:
  NUM_WORKERS: 15

concurrency:
  group: build-docs-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Generates a JSON list that is used by the strategy.matrix of the build job to spawn multiple workers
  compute-build-strategy-matrix:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Install QML Pipeline Utils
        run: |
          cd .github/workflows/qml_pipeline_utils
          pip install .

      # Optimization for pull requests. Instead of pulling the execution times on each synchronize,
      # only pull first time, this ensures the same set of demos always land on the same workers,
      # providing a boosted build time for subsequent runs.
      - name: Executions Time
        id: execution_time_cache
        if: github.event_name == 'pull_request'
        uses: actions/cache@v3
        with:
          path: execution_times.json
          key: execution_times-${{ github.ref_name }}


      - name: Get Workflow Artifact target branch
        id: workflow_target_branch
        if: steps.execution_time_cache.outputs.cache-hit != 'true'
        run: |
          [[ "${{ github.ref_name }}" == "dev" || "${{ github.event.pull_request.base.ref }}" == "dev" ]] && name="dev" || name="master"
          echo "name=$name" >> $GITHUB_OUTPUT

      - name: Get Workflow run ID
        id: workflow_run_id
        if: steps.execution_time_cache.outputs.cache-hit != 'true'
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            const destWorkflowBranch = "${{ steps.workflow_target_branch.outputs.name }}";

            try {
              const workflowRuns = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: `build-branch-${destWorkflowBranch}.yml`,
                branch: 'master',
                status: 'success',
                exclude_pull_requests: true,
                per_page: 1,
                page: 1
              });
              const runData = workflowRuns.data.workflow_runs;
              return (runData.length) ? runData[0].id : '';
            } catch (e) {
              console.log(`Unable to fetch workflow ID, error: ${e}`);
              return '';
            }

      - name: Download Demo Execution run times
        if: steps.workflow_run_id.outputs.result != '' && steps.execution_time_cache.outputs.cache-hit != 'true'
        uses: XanaduAI/cloud-actions/download-github-workflow-artifact@main
        with:
          workflow_run_id: ${{ steps.workflow_run_id.outputs.result }}
          artifact_name_regex: execution_times_${{ steps.workflow_target_branch.outputs.name }}
          github_token: ${{ github.token }}

      - name: Unpack execution times
        if: steps.workflow_run_id.outputs.result != '' && steps.execution_time_cache.outputs.cache-hit != 'true'
        run: |
          unzip execution_times_${{ steps.workflow_target_branch.outputs.name }}
          cat execution_times.json | jq

      - name: Compute GitHub Strategy Matrix
        id: compute-strategy-matrix
        run: |
          WK_LOAD_ARTIFACT_NAME='worker_load'
          WK_LOAD_FILE_NAME='worker_load.json'
          
          qml_pipeline_utils \
            build-strategy-matrix \
            --num-workers=${{ env.NUM_WORKERS }} \
            --examples-dir='${{ github.workspace }}/demonstrations' \
            ${{ steps.workflow_run_id.outputs.result != '' 
                 && format('--sphinx-examples-execution-times-file={0}/execution_times.json', github.workspace) 
                 || '' }} > "$WK_LOAD_FILE_NAME"
          
          echo "worker_load_artifact_name=$WK_LOAD_ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "worker_load_file_name=$WK_LOAD_FILE_NAME" >> $GITHUB_OUTPUT
          
          cat "$WK_LOAD_FILE_NAME" | jq
          
          worker_count=$(jq -r '.workers | length' "$WK_LOAD_FILE_NAME")
          matrix=$(python -c "print(list(range($worker_count)))")
          echo "strategy-matrix=$matrix" >> $GITHUB_OUTPUT

      - name: Upload worker load data as artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.compute-strategy-matrix.outputs.worker_load_artifact_name }}
          path: ${{ steps.compute-strategy-matrix.outputs.worker_load_file_name }}

    outputs:
      strategy-matrix: ${{ steps.compute-strategy-matrix.outputs.strategy-matrix }}
      worker-load-file-name: ${{ steps.compute-strategy-matrix.outputs.worker_load_file_name }}
      worker-load-artifact-name: ${{ steps.compute-strategy-matrix.outputs.worker_load_artifact_name }}

  build:
    runs-on: ubuntu-22.04
    needs:
      - compute-build-strategy-matrix
    strategy:
      matrix:
        offset: ${{ fromJson(needs.compute-build-strategy-matrix.outputs.strategy-matrix) }}
    env:
      ignore_cache: ${{ contains(github.event.pull_request.labels.*.name, 'ignore-qml-cache') }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Set up Python
        id: setup_python
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Install QML Pipeline Utils
        run: |
          cd .github/workflows/qml_pipeline_utils
          pip install .

      - name: Download worker load data
        uses: actions/download-artifact@v3
        with:
          name: ${{ needs.compute-build-strategy-matrix.outputs.worker-load-artifact-name }}

      - name: Extract Worker Tasks
        id: worker_tasks
        env:
          worker_id: ${{ matrix.offset }}
          worker_load_file_name: ${{ needs.compute-build-strategy-matrix.outputs.worker-load-file-name }}
        run: |
          WK_TASKS_FILE_NAME='worker_tasks.json'
          jq .workers[${{ env.worker_id }}].tasks ${{ env.worker_load_file_name }} > "$WK_TASKS_FILE_NAME"
          
          cat "$WK_TASKS_FILE_NAME" | jq
          
          echo "file_name=$WK_TASKS_FILE_NAME" >> $GITHUB_OUTPUT 

      - name: Install Python Dependencies
        run: |
          pip install -r requirements.txt
          pip install --no-deps -r requirements_no_deps.txt
          pip install --upgrade pip 'setuptools<65' cmake

      # Creates a temp yaml file with current environment information:
      # ```
      #  none: arbitrary value, we can change this to invalidate all previous caches if needed
      #  num_workers: The total number of workers currently spawned
      #  worker_id: The offset in the strategy matrix for the current worker
      #  python.version: The version of python that was setup using actions/setup-python
      #  python.hash.requirements-txt: The hash of the requirements.txt file
      #  python.hash.requirements_no_deps-txt: The hash of the requirements_no_deps.txt file
      # ```
      # The hash of this file is used as portion of the key in subsequent caching steps.
      # This ensures that if the values in this file change,
      # it will invalidate the previous cache and build fresh.
      - name: Set Matrix offset file
        run: |
          worker_files=$(jq [.[].name] worker_tasks.json | sed 's/^/  /')
          cat >matrix_info.yaml <<EOL
          nonce: a
          
          num_workers: ${{ env.NUM_WORKERS }}
          worker_id: ${{ matrix.offset }}
          
          python:
            version: ${{ steps.setup_python.outputs.python-version }}
            hash:
              requirements-txt: ${{ hashFiles('requirements.txt') }}
              requirements_no_deps-txt: ${{ hashFiles('requirements_no_deps.txt') }}
          
          worker_files: |
          $worker_files
          EOL

          cat matrix_info.yaml

      - name: Generate hash of the matrix file
        id: matrix_file
        run: |
          echo "hash=${{ hashFiles('matrix_info.yaml') }}" >> $GITHUB_OUTPUT

      - name: Install OS build dependencies
        run: |
          sudo apt-get install -y pandoc --quiet

      # Removes executable code from tutorials that are not relevant to current node
      # See documentation in github_job_scheduler.py for more details.
      - name: Remove extraneous executable code from demos
        run: |
          qml_pipeline_utils \
          remove-executable-code-from-extraneous-demos \
          --worker-tasks-file-loc="${{ steps.worker_tasks.outputs.file_name }}" \
          --examples-dir="${{ github.workspace }}/demonstrations" \
          --verbose

      - name: Gallery Cache
        uses: actions/cache@v3
        with:
          path: demos
          key: gallery-${{ steps.matrix_file.outputs.hash }}-${{ github.ref_name }}-${{ github.sha }}
          restore-keys: |
            gallery-${{ steps.matrix_file.outputs.hash }}-${{ github.ref_name }}-
            gallery-${{ steps.matrix_file.outputs.hash }}-

      - name: Sphinx Cache
        uses: actions/cache@v3
        with:
          path: sphinx_cache-${{ steps.matrix_file.outputs.hash }}
          key: sphinx-${{ steps.matrix_file.outputs.hash }}-${{ github.ref_name }}-${{ github.sha }}
          restore-keys: |
            sphinx-${{ steps.matrix_file.outputs.hash }}-${{ github.ref_name }}-
            sphinx-${{ steps.matrix_file.outputs.hash }}-

      - name: Clear Cache
        if: env.ignore_cache == 'true'
        env:
          sphinx_cache_filename: sphinx_cache-${{ steps.matrix_file.outputs.hash }}
        run: |
          if [ -d demos ]; then rm -rf demos; fi
          if [ -d ${{ env.sphinx_cache_filename }} ]; then rm -rf ${{ env.sphinx_cache_filename }}; fi

      - name: Build Tutorials
        run: |
          make download
          make SPHINXOPTS="-d sphinx_cache-${{ steps.matrix_file.outputs.hash }}" html

      # These are files that are generated as part of sphinx-build but are not needed and supported on the live website
      # There does not seem to be an option to "not" generate them, therefore this step deletes these files before they
      # are published to the live website.
      - name: Update sitemap.xml
        run: |
          qml_pipeline_utils \
          clean-sitemap \
          --build-dir="${{ github.workspace }}/_build/html" \
          --html-files="demos/sg_execution_times.html" \
          --verbose

      # Removes built html files that are not relevant to current node
      # See documentation in github_job_scheduler.py for more details.
      - name: Clean HTML Files
        if: matrix.offset == 0
        run: |
          qml_pipeline_utils \
          remove-extraneous-built-html-files \
          --worker-tasks-file-loc="${{ steps.worker_tasks.outputs.file_name }}" \
          --build-dir="${{ github.workspace }}/_build/html" \
          --examples-dir="${{ github.workspace }}/demonstrations" \
          --preserve-non-sphinx-images \
          --verbose

      - name: Clean HTML Files and Images
        if: matrix.offset != 0
        run: |
          qml_pipeline_utils \
          remove-extraneous-built-html-files \
          --worker-tasks-file-loc="${{ steps.worker_tasks.outputs.file_name }}" \
          --build-dir="${{ github.workspace }}/_build/html" \
          --examples-dir="${{ github.workspace }}/demonstrations" \
          --verbose

      - name: Upload Html
        if: matrix.offset == 0
        uses: actions/upload-artifact@v3
        with:
          name: html-${{ matrix.offset }}.zip
          if-no-files-found: error
          retention-days: 1
          path: _build/html

      # Only upload demos since all other html files are pushed as artifact from offset 0
      # This step excludes static files (files that are the same across all workers) from being included in the
      # built artifact. This is done as a performance boost.
      # The step above this is executed by only one worker which uploads all static content.
      - name: Upload Demo Html
        if: matrix.offset != 0
        uses: actions/upload-artifact@v3
        with:
          name: html-${{ matrix.offset }}.zip
          if-no-files-found: error
          retention-days: 1
          path: |
            _build/html
            !_build/html/*.html
            !_build/html/*.js
            !_build/html/*.xml
            !_build/html/_static
            !_build/html/glossary

  save-build-context:
    runs-on: ubuntu-22.04
    needs:
      - build
    steps:
      - name: Save Pull Request Event Context
        if: github.event_name == 'pull_request'
        run: |
          mkdir -p /tmp/pr
          cat >/tmp/pr/pr_info.json <<EOL
          {
            "id": "${{ github.event.pull_request.number }}",
            "ref": "${{ github.event.pull_request.head.sha }}",
            "ref_name": "${{ github.event.pull_request.head.ref }}"
          }
          EOL
      - name: Upload Pull Request Event Context as Artifact
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v3
        with:
          name: pr_info.zip
          path: /tmp/pr
          retention-days: 30

      # Will run to create an artifact containing key push event information
      - name: Save Push Event Context
        if: github.event_name == 'push'
        run: |
          mkdir -p /tmp/push
          cat >/tmp/push/push_info.json <<EOL
          {
            "ref": "${{ github.sha }}",
            "ref_name": "${{ github.ref_name }}"
          }
          EOL
      - name: Upload Push Event Context as Artifact
        if: github.event_name == 'push'
        uses: actions/upload-artifact@v3
        with:
          name: push_info.zip
          path: /tmp/push
          retention-days: 30
